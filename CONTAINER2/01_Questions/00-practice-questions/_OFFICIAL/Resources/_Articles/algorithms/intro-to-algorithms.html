<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="A description of the page and its contents" />
  <link rel="stylesheet" href="styles.css" />
  <title>Page Title</title>
  
  
  
  
  
        <link rel="stylesheet" href="./../../../assets/style.css" />
        <link rel="stylesheet" href="./../../../assets/prism.css" />
        <script async src="./../../../assets/prism.js"></script>
  
  
  
  
  
</head>

<body>
  <h1 id="intro-to-algorithms">Intro to Algorithms</h1>
  <h3 id="projected-time">Projected Time</h3>
  <p>30-45 minutes total</p>
  <ul>
    <li>Lesson - 20 min</li>
    <li>Video - 6 min</li>
    <li>Independent Practice - 10 min</li>
    <li>Check for Understanding - 10 min</li>
  </ul>
  <h3 id="prerequisites">Prerequisites</h3>
  <p>Required:</p>
  <ul>
    <li><a class="btn" href="/runtime-complexity/runtime-complexity.md">Runtime Complexity</a></li>
    <li><a class="btn" href="/data-structures/intro-to-data-structures.md">Intro to Data Structures</a></li>
  </ul>
  <p>Recommended:</p>
  <ul>
    <li><a class="btn" href="/data-structures/trees.md">Trees</a></li>
    <li><a class="btn" href="/data-structures/linked-lists.md">Linked Lists</a></li>
    <li><a class="btn" href="/data-structures/hash-tables.md">Hash Tables</a></li>
  </ul>
  <h3 id="motivation">Motivation</h3>
  <p>Let’s say the zombie apocalypse happens and you have to get to the coast because there’s a boat that’s waiting to
    take you away to safety, but only if you drive a car full of supplies to them. You didn’t think they would let you
    on the boat for free, did you? But there’s a problem: strange city and no google maps. So what do you do? At every
    intersection, you turn toward whichever road leads west. If you’re heading west and the road curves to the right too
    far, you just turn left at the next intersection. If that road curves to the left too far, you turn right. This is
    an algorithm, and algorithms like this might save your life.</p>
  <p>Barring that, you’ll need to know algorithms because designing the wrong one will probably mean your code will be
    slow crazy. They’re also commonly referenced in engineering job interviews, and if you don’t pass that then you
    won’t get the job. If you’re comfortable with both of these, you can skip this course.</p>
  <p><strong>Which companies use algorithms?</strong> The top most companies using algorithms are:</p>
  <ul>
    <li><a class="btn" href="http://www.tilr.com/blog/5-algorithm-technologies-you-use-everyday/">Siri</a></li>
    <li><a class="btn" href="http://www.tilr.com/blog/5-algorithm-technologies-you-use-everyday/">Netflix</a>.</li>
  </ul>
  <h3 id="objectives">Objectives</h3>
  <p><strong>Apprentices will be able to:</strong></p>
  <ul>
    <li>Describe what an algorithm is</li>
    <li>Review Big-O complexity</li>
  </ul>
  <h3 id="materials">Materials</h3>
  <ul>
    <li><a class="btn"
        href="https://docs.google.com/presentation/d/1WlG5OgF0gf9fQYEEgIysNSfNaMiCASBi8RJa25SwMC4/edit?usp=sharing">Slideshow:
        Intro to Algorithms</a></li>
    <li><a class="btn" href="https://youtu.be/CvSOaYi89B4">Video: What is an algorithm and why should you care?</a></li>
  </ul>
  <h3 id="lesson">Lesson</h3>
  <h4 id="changing-constraints">Changing Constraints</h4>
  <p>An algorithm is kind of like the second half of a cooking recipe. The first half lists the ingredients, and the
    second half will list what to do with them. Algorithms are a set of procedures. There isn’t always a “correct”
    algorithm; your algorithm choice depends a little on the context of the question.</p>
  <p>Let’s say you’re making a sandwich. You might start with two slices of bread, take a knife and dip it in peanut
    butter and paint one slice with that. Then you clean your knife, then dip it in jelly, then paint the other slice.
    Then you clean your knife again, and put it away. Now you put the bread together and enjoy. It took you 30 seconds.
  </p>
  <p>But what if you’re making 10 sandwiches for you and your best friends? You could do the above 10 times, but you’ll
    find yourself cleaning your knife a lot and it would take you 5 minutes (30 seconds * 10), so instead you put out 20
    slices of bread, paint half of them with peanut butter, then clean your knife, then paint the other half with jelly.
    Then you clean your knife and put it away. Then you put all the breads together and enjoy, and you find it took you
    half the time of 2 minutes 30 seconds! So efficient, and your friends are all impressed.</p>
  <p>That might make sense, but maybe you live in a tiny San Francisco apartment and you only have a small amount of
    space to work with. The second solution made sense given infinite prep space, but now the constraints of the problem
    have changed, and you actually do have to do the first method 10 times. It still takes 5 minutes, life is suffering
    but you work with what you got.</p>
  <p>You can expect to find these sort of changing constraints in software engineering as well. Perhaps the preparation
    space size is like the memory you have on your computer. You might have a huge dataset of like financial records
    from the entire year that’s so big you can’t fit it in memory. You can fit a day’s worth of transactions in memory,
    so you read that in and sum up all of them. Then you read the next day’s, and add that to the sum. Then you read the
    next, and eventually you have the sum for the entire year.</p>
  <h4 id="scaling">Scaling</h4>
  <p>You start a sandwich business, and need to make n=100 sandwiches. That takes 25 minutes. Then business gets big and
    it takes you 250 minutes.</p>
  pre data-role="codeBlock" data-info="js" class="language-javascript"><code>n=10   t=2.5
n=100  t=25
n=1000 t=250</code></pre>
  <p>It’s almost like each sandwich takes a constant amount of time to make, following the formula</p>
  pre data-role="codeBlock" data-info="js" class="language-javascript"><code>sandwiches = time_in_minutes / 4</code></pre>
  <p>When graphed, this looks like a linear line. In computer science, we have a notation for something that takes
    linear-time, and call it Big-O notation. It looks like this:</p>
  pre data-role="codeBlock" data-info="js" class="language-javascript"><code>O(n)</code></pre>
  <p>Let’s say you have a magic genie who will grant you any wish. You already used your first two wishes on stupid
    stuff, so now you want to make a wish for a lot of sandwiches. Only deal is you have to type out how many sandwiches
    you want on a calculator, and you can only press a button on the calculator once every minute. So you start out… you
    press “100”… you’re about to get nearly 100 sandwiches, but it took you 3 minutes to press that. One minute later
    “1000”… One minute later “10000”… every minute that goes by you get 10 times as many sandwiches. It’s like your
    sandwiches are increasing exponentially. In Big-O it looks like this:</p>
  pre data-role="codeBlock" data-info="js" class="language-javascript"><code>O(n^10)</code></pre>
  <p>Typically you will usually see O(n^2) because computers tend to do things in binary, and because <code>if</code>
    statements tend to make binary choices of “do this or do that”.</p>
  <p>So now the genie gets annoyed. He’s like just say what you want, nevermind the calculator. So you say “I would like
    ten billion sandwiches”. You get it. Cool, you solved world hunger. You could have said any number, and it takes
    just as much time. We call this “constant time”, and you’ll see this referred to as</p>
  pre data-role="codeBlock" data-info="js" class="language-javascript"><code>O(1)</code></pre>
  <p>The “1” here could be 20, or 50. It’s still 1, because there are no units and no scale.</p>
  <h3 id="common-mistakes-misconceptions">Common Mistakes / Misconceptions</h3>
  <ul>
    <li>
      <p>There is always a best algorithm for any problem</p>
      <p>Not true! With any algorithm there are tradeoffs. Maybe one algorithm can sum up all of the numbers in a table
        in 4 minutes, but it <em>always</em> takes 4 minutes no matter if there are 10 rows or 10,000 rows. Another
        algorithm might take 2 seconds to run per row, which is great when you have 10 rows, but when you have 10,000
        and you’ve been waiting 5 hours for your query to come back and it’s Friday night and your friends are all out
        having fun, you might wish it had finished in 4 minutes. Unless you don’t like having fun. Life is full of
        choices.</p>
    </li>
  </ul>
  <h3 id="independent-practice">Independent Practice</h3>
  <p>Split into pairs, and have paper and a pen or pencil ready. If someone gave you a page number, write step-by-step
    literal directions for how you would find that page in a book. Would your directions still work with a different
    page number?</p>
  <h3 id="check-for-understanding">Check for Understanding</h3>
  <p>On your own, write step-by-step literal directions for how to find wifi for your laptop in a new building. What
    would you do if your first options failed? What would be the next step if they all failed?</p>

</body>

</html>
