<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="A description of the page and its contents" />
  <link rel="stylesheet" href="styles.css" />
  <title>Page Title</title>
        <link rel="stylesheet" href="./../../../assets/style.css" />
        <link rel="stylesheet" href="./../../../assets/prism.css" />
        <script async src="./../../../assets/prism.js"></script>
</head>

<body>
  <h1 id="detailed-analysis-of-the-trapping-rain-water-problem">Detailed analysis of the trapping rain water problem
  </h1>
  <p><strong>Translator: <a class="btn" href="https://github.com/Iruze">Iruze</a></strong></p>
  
  <p>The trapping rain water problem is very interesting and preforms frequently in interviews. So this paper will show
    how to solve the problem and explain how to optimize the solution step by step.</p>
  <p>First of all, let’s have a view on the problem:</p>
  <p><img src="./pictures/trapping_rain_water/title.jpg" /></p>
  <p>In a word, an array represents an elevation map and hope you calculate how much rain water the elevation map can
    hold at most.</p>
  <div id=">pre data-role=" codeBlock" data-info="js" class="language-javascript"><code><a   title=" 1"><span>int</span> <span>trap</span>(<span>int</span>[]
    height);</a></code></pre>
  </div>
  <p>Now I will explain three approaches from shallow to deep: Brute force -&gt; Using memorandum -&gt; Using two
    pointers, and finally solve the problem with O(1) space complexity and O(N) time complexity.</p>
  <h3 id="i.-core-idea">I. Core idea</h3>
  <p>When I saw this problem for the first time, I had no idea at all. I believe that many friends have the same
    experience. As for this kind of problem, we should not consider from the whole, but from the part; Just as the
    previous articles that talk about how to handle the string problem, don’t consider how to handle the whole string.
    Instead, you should focus on how to handle each character among the string.</p>
  <p>Therefore, we find that the thought of this problem is sample. Specifically, just for the position <code>i</code>
    as below, how much water can it hold?</p>
  <p><img src="./pictures/trapping_rain_water/0.jpg" /></p>
  <p>Position <code>i</code> occupies 2 grids for holding water. Why it happens to hold 2 grids of water? Because the
    height of <code>height[i]</code> is 0, and <code>height[i]</code> can hold up to 2 grids of water, therefore there
    exists 2 - 0 = 2.</p>
  <p>But why the position <code>i</code> can hold 2 grids of water at most? Because the height of water column at
    position <code>i</code> depends on both the hightest water column on the left and the highest water column on the
    right. We describe the height of the two highest water columns as <code>l_max</code> and <code>r_max</code>
    respectively. <strong>Thus the height at position <code>i</code> is <code>min(l_max, r_max)</code></strong>.</p>
  <p>Further more, as for the position <code>i</code>, how much water it holds can be demonstrated as:</p>
  <div id=">pre data-role=" codeBlock" data-info="js" class="language-javascript"><code><a   title=" 1">water[i] <span>=</span> <span>min</span>(</a>
            <a id=-2" title="2"> <span># the highest column on the left</span></a>
    <a id=-3" title="3"> <span>max</span>(height[<span>0</span>..i]), </a>
    <a id=-4" title="4"> <span># the highest column on the right</span></a>
    <a id=-5" title="5"> <span>max</span>(height[i..end]) </a>
    <a id=-6" title="6"> ) <span>-</span> height[i]</a></code></pre>
    </div>
    <p><img src="./pictures/trapping_rain_water/1.jpg" /></p>
    <p><img src="./pictures/trapping_rain_water/2.jpg" /></p>
  <p>This is the core idea of the problem, so we can program a simple brute approach:</p>
  <div id=">pre data-role=" codeBlock" data-info="js" class="language-javascript"><code><a   title=" 1"><span>int</span> trap(vector&lt;<span>int</span>&gt;&amp; height) {</a>
            <a title="2"> <span>int</span> n = height.size();</a>
            <a title="3"> <span>int</span> ans = <span>0</span>;</a>
            <a id=-4" title="4"> <span>for</span> (<span>int</span> i = <span>1</span>; i &lt; n - <span>1</span>; i++) {</a>
            <a id=-5" title="5"> <span>int</span> l_max = <span>0</span>, r_max = <span>0</span>;</a>
            <a id=-6" title="6"> <span>// find the highest column on the right</span></a>
            <a id=-7" title="7"> <span>for</span> (<span>int</span> j = i; j &lt; n; j++)</a>
            <a id=-8" title="8"> r_max = max(r_max, height[j]);</a>
            <a id=-9" title="9"> <span>// find the highest column on the right</span></a>
            <a id=-10" title="10"> <span>for</span> (<span>int</span> j = i; j &gt;= <span>0</span>; j--)</a>
            <a id=-11" title="11"> l_max = max(l_max, height[j]);</a>
            <a id=-12" title="12"> <span>// if the position i itself is the highest column</span></a>
            <a id=-13" title="13"> <span>// l_max == r_max == height[i]</span></a>
            <a id=-14" title="14"> ans += min(l_max, r_max) - height[i];</a>
            <a id=-15" title="15"> }</a>
            <a id=-16" title="16"> <span>return</span> ans;</a>
            <a id=-17" title="17">}</a></code></pre>
  </div>
  <p>According to the previous thought, the above approach seems very direct and brute. The time complexity is O(N^2)
    and the space complexity is O(1). However, it is obvious that the way of calculating <code>r_max</code> and
    <code>l_max</code> is very clumsy, which the memorandum is generally introduced to optimize the way.
  </p>
  <h3 id="ii.-memorandum-optimization">II. Memorandum Optimization</h3>
  <p>In the previous brute approach, the <code>r_max</code> and <code>l_max</code> are calculated at every position
    <code>i</code>. So we can cache that calculation results, which avoids the stupid traversal at every time. Thus the
    time complexity will reasonably decline.
  </p>
  <p>Here two arrays <code>r_max</code> and <code>l_max</code> are used to act the memo. <code>l_max[i]</code>
    represents the highest column on the left of position <code>i</code> and <code>r_max[i]</code> represents the
    highest column on the right of position <code>i</code>. These two arrays are calculated in advance to avoid
    duplicated calculation.</p>
  <div id=">pre data-role=" codeBlock" data-info="js" class="language-javascript"><code><a   title=" 1"><span>int</span> trap(vector&lt;<span>int</span>&gt;&amp; height) {</a>
            <a id=-2" title="2"> <span>if</span> (height.empty()) <span>return</span> <span>0</span>;</a>
            <a id=-3" title="3"> <span>int</span> n = height.size();</a>
            <a id=-4" title="4"> <span>int</span> ans = <span>0</span>;</a>
            <a id=-5" title="5"> <span>// arrays act the memo</span></a>
            <a id=-6" title="6"> vector&lt;<span>int</span>&gt; l_max(n), r_max(n);</a>
            <a id=-7" title="7"> <span>// initialize base case</span></a>
            <a id=-8" title="8"> l_max[<span>0</span>] = height[<span>0</span>];</a>
            <a id=-9" title="9"> r_max[n - <span>1</span>] = height[n - <span>1</span>];</a>
            <a id=-10" title="10"> <span>// calculate l_max from left to right</span></a>
            <a id=-11" title="11"> <span>for</span> (<span>int</span> i = <span>1</span>; i &lt; n; i++)</a>
            <a id=-12" title="12"> l_max[i] = max(height[i], l_max[i - <span>1</span>]);</a>
            <a id=-13" title="13"> <span>// calculate r_max from right to left</span></a>
            <a id=-14" title="14"> <span>for</span> (<span>int</span> i = n - <span>2</span>; i &gt;= <span>0</span>; i--) </a>
            <a id=-15" title="15"> r_max[i] = max(height[i], r_max[i + <span>1</span>]);</a>
            <a id=-16" title="16"> <span>// calculate the final result</span></a>
            <a id=-17" title="17"> <span>for</span> (<span>int</span> i = <span>1</span>; i &lt; n - <span>1</span>; i++) </a>
            <a id=-18" title="18"> ans += min(l_max[i], r_max[i]) - height[i];</a>
            <a id=-19" title="19"> <span>return</span> ans;</a>
            <a id=-20" title="20">}</a></code></pre>
  </div>
  <p>Actually, the memo optimization has not much difference from the above brute approach, except that it avoids repeat
    calculation and reduces the time complexity to O(N). Although time complexity O(N) is already the best, but the
    space complexity is still O(N). So let’s look at a more subtle approach that can reduce the space complexity to
    O(1).</p>
  <h3 id="iii.-two-pointers">III. Two pointers</h3>
  <p>The thought of this approach is exactly the same, but it is very ingenious in the way of implementation. We won’t
    use the memo to cache calculation results in advance this time. Instead, we use two pointers to calculate during
    traversal and the space complexity will decline as a result.</p>
  <p>First, look at some of the code:</p>
  <div>
    pre data-role="codeBlock" data-info="js" class="language-javascript"><code><a   title="1"><span >int</span> trap(vector&lt;<span >int</span>&gt;&amp; height) {</a>
<a  id=-2" title="2">    <span >int</span> n = height.size();</a>
<a  id=-3" title="3">    <span >int</span> left = <span >0</span>, right = n - <span >1</span>;</a>
<a  id=-4" title="4">    </a>
<a  id=-5" title="5">    <span >int</span> l_max = height[<span >0</span>];</a>
<a  id=-6" title="6">    <span >int</span> r_max = height[n - <span >1</span>];</a>
<a  id=-7" title="7">    </a>
<a  id=-8" title="8">    <span >while</span> (left &lt;= right) {</a>
<a  id=-9" title="9">        l_max = max(l_max, height[left]);</a>
<a  id=-10" title="10">        r_max = max(r_max, height[right]);</a>
<a  id=-11" title="11">        left++; right--;</a>
<a  id=-12" title="12">    }</a>
<a id=-13" title="13">}</a></code></pre>
</div>
  <p>In the above code, what’s the meaning of <code>l_max</code> and <code>r_max</code> respectively?</p>
  <p>It is easy to understand that <strong><code>l_max</code> represents the highest column among
      <code>height[0..left]</code> and <code>r_max</code> represents the highest column among
      <code>height[right..end]</code></strong>.</p>
  <p>With that in mind, look directly at the approach:</p>
  <div id=">pre data-role=" codeBlock" data-info="js" class="language-javascript"><code><a   title=" 1"><span>int</span> trap(vector&lt;<span>int</span>&gt;&amp; height) {</a>
            <a id=-2" title="2"> <span>if</span> (height.empty()) <span>return</span> <span>0</span>;</a>
            <a id=-3" title="3"> <span>int</span> n = height.size();</a>
            <a id=-4" title="4"> <span>int</span> left = <span>0</span>, right = n - <span>1</span>;</a>
            <a id=-5" title="5"> <span>int</span> ans = <span>0</span>;</a>
            <a id=-6" title="6"> </a>
            <a id=-7" title="7"> <span>int</span> l_max = height[<span>0</span>];</a>
            <a id=-8" title="8"> <span>int</span> r_max = height[n - <span>1</span>];</a>
            <a id=-9" title="9"> </a>
            <a id=-10" title="10"> <span>while</span> (left &lt;= right) {</a>
            <a id=-11" title="11"> l_max = max(l_max, height[left]);</a>
            <a id=-12" title="12"> r_max = max(r_max, height[right]);</a>
            <a id=-13" title="13"> </a>
            <a id=-14" title="14"> <span>// ans += min(l_max, r_max) - height[i]</span></a>
            <a id=-15" title="15"> <span>if</span> (l_max &lt; r_max) {</a>
            <a id=-16" title="16"> ans += l_max - height[left];</a>
            <a id=-17" title="17"> left++; </a>
            <a id=-18" title="18"> } <span>else</span> {</a>
            <a id=-19" title="19"> ans += r_max - height[right];</a>
            <a id=-20" title="20"> right--;</a>
            <a id=-21" title="21"> }</a>
            <a id=-22" title="22"> }</a>
            <a id=-23" title="23"> <span>return</span> ans;</a>
            <a id=-24" title="24">}</a></code></pre>
  </div>
  <p>The core idea of the approach is the same as before, which is just like old wine in new bottle. However, a careful
    reader may find that the approach is slightly different in details from the previous ones:</p>
  <p>In the memo optimization approach, <code>l_max[i]</code> and <code>r_max[i]</code> represent the highest column of
    <code>height[0..i]</code> and <code>height[i..end]</code> respectively.
  </p>
  <div id="cb7">
    pre data-role="codeBlock" data-info="js"
    class="language-javascript"><code><a   title="1">ans += min(l_max[i], r_max[i]) - height[i];</a></code></pre>
  </div>
  <p><img src="./pictures/trapping_rain_water/3.jpg" /></p>
  <p>But in two pointers approach, <code>l_max</code> and <code>r_max</code> represent the highest column of
    <code>height[0..left]</code> and <code>height[right..end]</code> respectively. Take the below code as an example:
  </p>
  <div id="cb8">
    pre data-role="codeBlock" data-info="js" class="language-javascript"><code><a   title="1"><span >if</span> (l_max &lt; r_max) {</a>
<a  id="cb8-2" title="2">    ans += l_max - height[left];</a>
<a  id="cb8-3" title="3">    left++; </a>
<a id="cb8-4" title="4">} </a></code></pre>
</div>
<p><img src="./pictures/trapping_rain_water/4.jpg" /></p>
<p>At this time, <code>l_max</code> represents the highest column on the left of <code>left</code> pointer, but
  <code>r_max</code> is not always the highest column on the right of <code>left</code> pointer. Under the
  circumstances, can this approach really get the right answer?
</p>
<p>In fact, we need to think about it in this way: we just focus on <code>min(l_max, r_max)</code>. In the above
  elevation map, we have known <code>l_max &lt; r_max</code>, so it is doesn’t matter whether the <code>r_max</code>
  is the highest column on the right. The key is that water capacity in <code>height[i]</code> just depends on
  <code>l_max</code>.
</p>
<p><img src="./pictures/trapping_rain_water/5.jpg" /></p>
  <p><strong><em>Tip:</em></strong><br />
    Adhere to the original high-quality articles and strive to make the algorithm clear. Welcome to my Wechat official
    account: <strong>labuladong</strong> to get the latest articles.</p>

</body>

</html>
